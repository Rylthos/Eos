#version 450

layout (set = 0, binding = 0, rgba8) uniform writeonly image2D tex;

layout (local_size_x = 32, local_size_y = 32) in;

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct Sphere
{
    vec3 center;
    float radius;
};

struct HitRecord
{
    vec3 point;
    vec3 normal;

    bool isFrontFace;

    float t;
};

vec3 hitColour(in Ray ray, in Sphere sphere, in float t)
{
    vec3 hitPosition = ray.origin + (t * ray.direction);

    vec3 normal = normalize(hitPosition - sphere.center);

    return normal;
}

vec3 missColour(in Ray ray)
{
    const vec3 bottomLeft = vec3(0.5, 0.7, 0.8);
    const vec3 topRight = vec3(0.0, 0.3, 1.0);

    float mixValue = (ray.direction.x + ray.direction.y + 2.0) / 4.0;
    return mix(bottomLeft, topRight, mixValue);
}

float sphereHit(in Ray ray, in Sphere sphere)
{
    float a = dot(ray.direction, ray.direction);
    float b = 2 * dot(ray.direction, ray.origin - sphere.center);
    float c = dot(ray.origin - sphere.center, ray.origin - sphere.center) - sphere.radius * sphere.radius;

    float discriminant = b*b - 4*a*c;

    if (discriminant >= 0.0)
    {
        float t = -b + sqrt(discriminant) / 2*a;
        return t;
    }
    else
        return -1.0;
}

vec3 getSphereNormal(in Ray ray, in Sphere sphere, in float t)
{
    return normalize(ray.origin + ray.direction * t - sphere.center);
}

vec3 getRayColour(in Ray ray, in Sphere sphere)
{
    float t = sphereHit(ray, sphere);

    if (t > 0.0)
    {
        vec3 N = getSphereNormal(ray, sphere, t);

        return 0.5 * vec3(N.x + 1, N.y + 1, N.z + 1);
    }

    return missColour(ray);
}

void main()
{
    ivec2 dim = imageSize(tex);

    float aspect = float(dim.x) / float(dim.y);

    vec2 viewport = vec2(2, 2);
    viewport.x = aspect * viewport.y;

    const float focalLength = 1.0;
    const vec3 origin = vec3(0, 0, 0);

    const vec3 worldUp    = vec3(0, 1, 0);
    const vec3 worldRight = vec3(1, 0, 0);
    const vec3 worldFront = vec3(0, 0, 1);


    ivec2 threadPos = ivec2(gl_GlobalInvocationID.xy);

    vec3 horizontalDist = worldRight * viewport.x;
    vec3 verticalDist = worldUp * viewport.y;
    vec3 lowerLeftCorner = vec3(origin - (horizontalDist / 2) - (verticalDist / 2)
            + vec3(0, 0, focalLength));

    float u = float(threadPos.x) / float(dim.x);
    float v = float(threadPos.y) / float(dim.y);

    vec3 rayDirection = lowerLeftCorner + u*horizontalDist + v*verticalDist - origin;

    Ray ray;
    ray.origin = origin;
    ray.direction = rayDirection;

    Sphere sphere;
    sphere.center = vec3(0.0, 0.0, 1.0);
    sphere.radius = 0.5;

    vec3 colour = getRayColour(ray, sphere);

    imageStore(tex, threadPos, vec4(colour, 1.0));
}
