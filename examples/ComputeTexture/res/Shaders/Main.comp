#version 450

layout (set = 0, binding = 0, rgba8) uniform writeonly image2D tex;

layout (local_size_x = 32, local_size_y = 32) in;

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct Sphere
{
    vec3 center;
    float radius;
};

vec3 hitColour(in Ray ray, in Sphere sphere, in float t)
{
    vec3 hitPosition = ray.origin + (t * ray.direction);

    vec3 normal = normalize(hitPosition - sphere.center);

    return normal;
}

vec3 missColour(in Ray ray)
{
    const vec3 bottomLeft = vec3(0.0, 0.5, 0.8);
    const vec3 topRight = vec3(0.0, 0.0, 1.0);

    return mix(bottomLeft, topRight, (ray.origin.x + ray.origin.y + 2) / 4.0);
}

vec3 checkHit(in Ray ray, in Sphere sphere)
{
    float a = dot(ray.direction, ray.direction);
    float b = 2 * dot(ray.direction, ray.origin - sphere.center);
    float c = dot(ray.origin - sphere.center, ray.origin - sphere.center) - sphere.radius * sphere.radius;

    float discriminant = b*b - 4*a*c;

    if (discriminant >= 0.0)
    {
        float t = -b + sqrt(discriminant) / 2*a;
        return hitColour(ray, sphere, t);
    }
    else
        return missColour(ray);
}

void main()
{
    ivec2 dim = imageSize(tex);

    // Move 0,0 to center of screen and map origins to [-1, 1]
    vec3 rayOrigin = vec3(gl_GlobalInvocationID.xy, 0.0) - vec3(dim.x / 2, dim.y / 2, 0.0);
    rayOrigin.x /= dim.x / 2;
    rayOrigin.y /= dim.y / 2;

    vec3 rayDirection = vec3(0.0, 0.0, 1.0);

    Ray ray;
    ray.origin = rayOrigin;
    ray.direction = rayDirection;

    Sphere sphere;
    sphere.center = vec3(0.0, 0.0, 1.0);
    sphere.radius = 0.5;

    vec3 colour = checkHit(ray, sphere);

    imageStore(tex, ivec2(gl_GlobalInvocationID.xy), vec4(colour, 1.0));
}
